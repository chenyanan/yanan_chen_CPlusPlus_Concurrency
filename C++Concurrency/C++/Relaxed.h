//
//  Relaxed.h
//  C++Concurrency
//
//  Created by chenyanan on 2017/8/23.
//  Copyright © 2017年 chenyanan. All rights reserved.
//

#ifndef Relaxed_h
#define Relaxed_h

//  为了理解这是如何工作的,想象每个变量是一个在小间隔里使用记事本的人,在他的记事本上有一列值,你可以打电话给他,要求他给你一个值,或者你可以告诉他写下了一个新值,如果你告诉他写下新值,他就将其写在列表底部,如果你向他要一个值,他就为你从类表中读取一个数字

//  第一次你跟这个人交谈,如果你向他要一个值,此时他可能从他记事本上的列表里任意给你一个值,如果你接着向他要另一个值,他可能会再次给你同一个值,或是从列表下方给你一个,他永远不会给你一个在列表中更上面的值,如果你告诉他写下一个数字,然后再要一个值,他要么给你刚才你让他写下的数字,或者是列表上在那以下的数字

//  假设某一次他的列表以这些值开始5、10、23、3、1、2,如果你要一个值,你会得到其中的任意一个,如果他给你10,下一次他可能再给你一个10,或者后面的其他值,但不会是5,如果你呼叫他5次,举个例子,他可能会说"10,10,1,2,2",如果你告诉他写下42,他会将其添加在列表末尾,如果你再向他要数字,他将一直告诉你"42",直到他的列表上有另一个数,并且他愿意告诉你时

//  现在,假设你的朋友Carl也有这个人的号码,Carl也可以打电话给他,要么请他写下一个数字或是索取一个数字,他跟对待你一样,对Carl应用相同的规则,他只有一部电话,因此它一次只能处理你们中的一个人,所以他记事本上的列表是一个非常直观的列表,但是,仅仅因为你让他写下了新的号码,并不意味着他必须将其告诉Carl,反之亦然,如果Carl向他索取一个数字,并被告知"23",然后仅仅因为你要求这个人写下42并不意味着他下一次就会告诉Carl,他可能会将23、3、1、2、42这些数字中的任何一个告诉Carl,或者甚至是你在呼叫他之后,Fred告诉他写下来的67,他很可能会告诉Carl"23、3、3、1、67",这与他告诉你的也没什么矛盾,就像是他为每个人设了一个小小的移动便签,把他对谁说了什么数都进行了记录,如图5.5所示

//             5
//             10
//             23   carl dave
//             3
//             1
//        anne 2
//             42   you
//        fred 67

//  现在假设不仅仅是一个人在一个小隔间,而是整个隔间群,有一大帮带着电话和笔记本的人,这些都是我们的原子变量,每一个变量都有自己的修改顺序(笔记本上的列表的值),但是它们之间完全没有关系,如果任意一个呼叫者(你,Carl,Anne,Dave,Fred)是一个线程,那么这就是每个操作都使用memory_order_relaxed是你所得到的东西,还有一些你可以告诉隔间里的人的额外的事情,比如"记下这个号码,并告诉我列表的底部是什么"(exchange)和"写下这个数字,如果列表底部的数字正是它,否则告诉我应该猜到什么"(compare_exchange_strong),但是这并不影响一般的原则

//  小隔间中的有一个话务员X，他手中的笔记本记录了一串数字，X将客户告诉他的数字追加到串尾，X会按照从前往后的顺序从第一个数开始每次将串中的一个数字告诉前来寻问的客户A，如果客户A问到了全部的数字并且继续询问，X将重复的告诉A最后一个数，X会负责记住不同的客户(B、C...)询问到串中的什么位置了，办公场地内存在好几个不同的话务员(Y、Z...)，他们在同一时刻各自读写各自的数串，只不过每个话务员只有一个电话，一次只能和一个客户通讯，需要特别注意的一点是，话务员在告诉客户数字之前会遮住串中的某些数字，从结果上看，客户得到的数字串是残缺的(和话务员手中的数字串相比，中间跳过了很多数字)，是重复的(会出现若干连在一起的重复数字)，是顺序的(即便残缺重复，数字的排列顺序亦然是从前往后，相比话务员手中的数字串，次序并没有颠倒，排在后面的数字不会先于排在前面的数字被告诉给客户)，并且不同的客户，残缺重复的情况各有不同，造成这种现象的原因是在多线程编程中，某个CPU里执行的一个写操作导致的内存变化不一定会马上就被另一个CPU看到，通俗的来讲，一边客户A让话务员X记录下的值$，另一边由于种种原因，X无法将$告诉给前来寻问数字的客户B，X只能将排在$后面的某个未被告诉给B的值%，或者排在$前面已经被告诉给B的值#(如果$是最新被写下的值)，告诉给客户B，如此一来就造成残缺(值%)和重复(值#)，话务员就是程序中的原子变量，而客户就是程序中的线程，上述模型模拟了松散顺序，不同线程的所有原子操作会被重排，即便编译器会按照原子操作在线程代码中的先后顺序对原子操作进行解释，程序却不保证原子操作按照线程代码中的顺序进行执行，这里仍然会乱序执行，需要注意的是同一个线程对单个原子变量的访问不能被重排,一旦给定的线程已经看到了原子变量的特定值,该线程之后的读取就不能获取该变量更早的值


#endif /* Relaxed_h */
