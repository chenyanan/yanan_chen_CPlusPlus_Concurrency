//
//  AcquireRelease.h
//  C++Concurrency
//
//  Created by chenyanan on 2017/8/25.
//  Copyright © 2017年 chenyanan. All rights reserved.
//

#ifndef AcquireRelease_h
#define AcquireRelease_h

//  仍然可以用带着笔记本在小隔间中工作的话务员这个形式来考虑获取-释放顺序,但是必须对模型添加更多,首先假定每个已完成的存储都是某个客户某批次更新操作的一部分,因此当他让话务员写下一个数字时,他也需要告诉话务员这次更新来自于哪个客户的第几个批次:"请写下99,作为客户X的第423批的一部分"(模拟存储-松散),对于一批的最后一次存储,他也可以这样告诉话务员:"请写下147,作为客户X的第423批的最后一笔"(模拟存储-释放),话务员会及时地写下这个数字,以及谁给了他这些值,这是第几个批次,这模拟了一个存储-释放操作,下次客户X告诉话务员一个新数字时,话务员应该增加批次号码:"请写下41,作为客户X的第424批的一部分"(模拟存储-松散)或者是"请写下41,作为客户X的第424批的最后一次存储"(模拟存储-释放)
//
//  可以仅仅询问一个值(模拟载入-松散),在此情况下话务员只会给你一个数字,或者询问某个客户某批次更新中的最后一笔(模拟载入-获取),一旦找到这样的数字，他会对你说"这个数字是xxx,是来自yyy的第zzz批的最后一笔"，如果找不到这种值,他会对你说"这个数字是xxx,仅仅是yyy第zzz批次更新中的一个'普通'的值",现在获取-释放语义闪耀登场:当你向话务员询问一个曾经作为某客户某批次更新的最后一笔的数字时,他会从他的列表中向下查找,找到你当前可见的任意一个批次的最后一笔,并且要么给你那个数字,要么列表更下方的一个数字
//
//  这是如何模拟获取-释放语义的呢？让我们看一看这个例子,最开始线程a运行write_x_then_y并对小间隔x内的人说,"请写下true作为线程a第一批的一部分",然后他及时地写下了,线程a随后对小间隔y内的人说,"请写下true作为线程a第一批的最后一笔",他也及时地写下了,于此同时,线程b运行着read_y_then_x,线程b持续地向小间隔y里的人索取带着批次信息的值,直到他说"true",他可能要询问很多次,但是最终这个人总会说"true",但是在小间隔y里的人不能仅仅说"true",他还要说"这是线程a第一批的最后一笔"
//
//  现在,线程b继续向盒子x里的人询问值,但是这一次他说:"请让我拥有一个值,并且通过这一方式让我知晓线程a的第一批",所以现在,小间隔x中的人必须查看他的列表,找到线程a中第一批的最后一次提及,他所具有的唯一一次提及是true值,同时也是列表上的最后一个值,所以他必须读取该值,否则,它会破坏游戏规则

//  获取-释放顺序在松散顺序的基础上加强了同步语义，一个线程中可能交替出现获取载入和松散载入，就像在松散顺序中那样，当客户前来询问时，话务员同样会遮住数字序列中的某些数，使数字序列在客户看来是不完整的，执行获取载入时，话务员会从当前游标开始向后遍历并跳过遮住的数字，直到找到第一个标记有某线程某批次的最后一笔的数字(某个线程释放存储下的数字)并要么将其回传要么将更下方的一个数字回传，被编写之后的松散载入代码执行起来会和松散顺序中的情况稍有不同，话务员这个时候不再像松散顺序时那样漫无目的的将游标向后移动，而是根据获取载入操作提供的线程和批次信息，直接从当前游标位置开始向后遍历并跳过遮住的数字，直到找到标记为这个线程这个批次的最后一次提及并将其返回，一个线程中可能交替出现释放载入和松散载入，相比松散顺序，获取-释放顺序中，话务员在存储数字时会记录线程及批次信息，松散存储的值会作为普通值被添加到当前批次的末尾，下一次松散存储来临时新数字会被继续添加到当前批次的末尾，释放存储的值会作为最后一笔被添加到当前批次的末尾，下一次释放存储来临时话务员会新开一个批次，话务员们之间的协作保证了线程A中发生在原子变量X上的释放存储之前的原子变量Y的松散存储(数字3)先于X的释放存储执行完成，于是线程B中发生在原子变量X的获取载入之后的原子变量Y的松散载入都能根据线程信息和批次信息获取到在线程A中最新更新的值(数字3)，当然前提是X的释放存储在X的获取载入之前执行，需要注意的是不同线程的所有原子操作会被重排，线程B中的操作可能会在线程A之前执行，X的获取载入可能发生在X的释放存储之前，这种情况下无论是X的获取载入还是之后Y的松散载入都得不到同步后的值，由此可见我们可能需要在获取-释放顺序中添加一些额外的同步手段(类似于while)，需要知道如果线程B中的操作全部发生在线程A中，那么实际上是不需要获取-释放语义的，因为即便是在同步最弱的松散语义中，同一个线程对单个原子变量的访问不能被重排,一旦给定的线程已经看到了原子变量的特定值,该线程之后的读取就不能获取该变量更早的值

#endif /* AcquireRelease_h */
